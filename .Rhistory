transactions <- genTrans(cycles = "y", spike = 12, outliers = 1, transactions = 10000)
customer2transaction <- buildPareto(customers, transactions$transactions, pareto = c(80,20))
head(customer2transaction)
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
product2transaction <- buildPareto(transactions$transactions, products$sku, pareto = c(70,30))
product2transaction <- buildPareto(products$SKU,transactions$transactions,pareto = c(70,30))
product2transaction
print(head(product2transaction))
?merge
transactions
head(transactions)
tail(transactions)
buildName <- function(numOfItems, prefix)
{
id <- formatC(seq(1, numOfItems), width=nchar(numOfItems), flag=0);
uid <- paste(prefix, id, sep="");
return(uid)
}
buildDistr <- function(st, en, cycles, trend)
{
#handle missing arguments
st <- missingArgHandler(st,1);
en <- missingArgHandler(en,12);
cycles <- missingArgHandler(cycles, "y");
if(cycles == "y")
{
a <- 0.5;
b <- 0.5;
}else if(cycles == "q")
{
a <- 2;
b <- sample(seq(0.5, 2.5, by = 0.25),1);
}else if(cycles == "m")
{
a <- 3;
b <- 0.25;
}
#generate intercept as a random int between 2 and 5
c <- sample(2:5,1);
trend <- missingArgHandler(trend, 1);
x <- seq(st,en,by=(en-st)/(en-1));
if(trend == 1 && cycles != "m")
{
distr <- sin(a*x) + cos(b*x) + c;
}else if(trend == 1 && cycles == "m")
{
distr <- sin(a*x) - cos(b*x) + c;
}else if(trend == -1 && cycles != "m")
{
distr <- sin(a*x) - cos(b*x) + c;
}else if(trend == -1 && cycles == "m")
{
distr <- sin(a*x) + cos(b*x) + c;
}
return(distr)
}
buildOutliers <- function(distr)
{
#compute the inter quartile range
q1 <- summary(distr)[[2]];
q3 <- summary(distr)[[5]];
iqr <- (q3-q1);
#compute the number of outliers needed. It is atleast 1 and atmost 3% of the distribution size
numOfOutliers <- max(0.03 * length(distr),1);
#compute the outliers by selecting the weight randomly.
outlierWts <- sample(seq(1.5, 3, by = 0.01),numOfOutliers);
outliers <- (outlierWts * iqr);
#replace randomly selected values with outlier values
selectedVals <- (sample(distr, numOfOutliers));
distr[distr %in% selectedVals] <- outliers[match(distr, selectedVals, nomatch = 0)];
return(distr);
}
buildPareto <- function(factor1, factor2, pareto)
{
#Exception handling.
paretoTotal <- (pareto[1]+pareto[2]);
if(paretoTotal != 100)
{
stop("Pareto values must add up to 100. For example, pareto = c(80,20)");
}
#randomise the sequence of the factors
factor1Shuffled <- sample(factor1);
factor2Shuffled <- sample(factor2);
#format the split thresholds
split1 <- pareto[1]*0.01;
split2 <- pareto[2]*0.01;
#split factor1 by the given split
factor1sample1 <- sample.int(n = length(factor1Shuffled), size = floor(split1*length(factor1Shuffled)), replace = F);
factor1p1 <- factor1Shuffled[factor1sample1];
factor1p2 <- factor1Shuffled[-factor1sample1];
#split factor2 by the given split
factor2sample1 <- sample.int(n = length(factor2Shuffled), size = floor(split1*length(factor2Shuffled)), replace = F);
factor2p1 <- factor2Shuffled[factor2sample1];
factor2p2 <- factor2Shuffled[-factor2sample1];
#map the factors based on the thresholds. map 80 to 20 and then 20 to 80
map1 <- sample(factor1p2, size = length(factor2p1), replace = TRUE,prob = NULL);
dfMap1 <- data.frame(factor2p1, map1);
names(dfMap1) <- c("factor2","factor1")
map2 <- sample(factor1p1, size = length(factor2p2), replace = TRUE,prob = NULL);
dfMap2 <- data.frame(factor2p2, map2);
names(dfMap2) <- c("factor2","factor1")
#build the final dataframe
dfMapFinal <- rbind(dfMap1, dfMap2);
return(dfMapFinal)
}
buildSpike <- function(distr, spike)
{
distrDf <- as.data.frame(distr);
names(distrDf) <- c("wt");
distrDf$mth <- as.numeric(row.names(distrDf));
maxVal <- max(distr);
maxValIndex <- as.numeric(row.names(distrDf[distrDf$wt==maxVal,]));
spikeMinusMaxvalindex <- (spike - maxValIndex);
distrDf$mthTemp <- (distrDf$mth + spikeMinusMaxvalindex);
distrDf$mthFinal <- ifelse(distrDf$mthTemp>12,(distrDf$mthTemp-12),distrDf$mthTemp);
distrDf <- distrDf[order(distrDf$mthFinal), ];
distrOut <- distrDf$wt;
return(distrOut);
}
sample(1:10)
as.data.frame(sample(1:10))
df <- as.data.frame(1:5)
df
names(df) <- trans
names(df) <- c('trans')
df
genTrans <- function(cycles, trend, transactions, spike, outliers)
{
#handle missing arguments
cycles <- missingArgHandler(cycles,"y");
trend <- missingArgHandler(trend,1);
transactions <- missingArgHandler(transactions,10000);
outliers <- missingArgHandler(outliers, 1);
#Exception handling.
if(transactions <= 0)
{
stop("Please enter non zero positive integers");
}else if(transactions < 10000)
{
warning("Insights may not be meaningful. Recommended number of transactions for meaningful insights is 10,000.")
}
if(spike > 12 | spike < 1)
{
stop("Please set spike between 1 and 12")
}
if(trend == 1 | trend == -1)
{
}else
{
stop("Please set trend as 1 or -1");
}
if(outliers == 1 | outliers == 0)
{
}else
{
stop("Please set outliers as 1 or 0");
}
#compute weights for 12 months
if(missing(spike))
{
aggDataMth <- as.data.frame(buildDistr(cycles = cycles, trend = trend));
}else
{
distr <- buildDistr(cycles = cycles, trend = trend);
distrspiked <- buildSpike(distr = distr, spike = spike);
aggDataMth <- as.data.frame(distrspiked);
}
colnames(aggDataMth) <- c('distrWt');
wts <- (transactions/sum(aggDataMth$distrWt));
aggDataMth$weights <- (aggDataMth$distrWt*wts);
aggDataMth$mth <- row.names(aggDataMth);
daysInMth <- data.frame(matrix(nrow = 12, ncol = 1))
aggDataMth$days <- c(31 ,28 ,31 ,30 ,31 ,30 ,31 ,31 ,30 ,31 ,30 ,31);
#compute weights for 4 weeks each month
for(i in 1:nrow(aggDataMth))
{
aggDataDayTemp <- as.data.frame(buildDistr(st = 1, en = (aggDataMth$days[i]), cycles = "y", trend = trend));
colnames(aggDataDayTemp) <- c('distrWtWk')
wts <- (aggDataMth$weights[i]/sum(aggDataDayTemp$distrWtWk));
aggDataDayTemp$weights <- (aggDataDayTemp$distrWtWk*wts);
aggDataDayTemp$mth <- aggDataMth$mth[i];
if(i == 1)
{
aggDataDay <- aggDataDayTemp;
}else
{
aggDataDay <- rbind(aggDataDay, aggDataDayTemp);
}
}
aggDataDay$transactions <- round(aggDataDay$weights);
aggDataDay$day <- 1:nrow(aggDataDay);
#add outliers
if(outliers == 1)
{
aggDataDay$transactions <- (buildOutliers(aggDataDay$transactions));
}else if(outliers == 0)
{
aggDataDay <- aggDataDay;
}
aggDataDay$transactions <- round(aggDataDay$transactions, 0);
#build dataframe at transaction level
dfFinal <- data.frame()#build empty df
for(i in 1:nrow(aggDataDay))
{
numOfTrans <- aggDataDay$transactions[i];
dayNum <- aggDataDay$day[i];
temp <- as.data.frame(buildName(numOfItems = numOfTrans, prefix = paste("txn","-",i,"-",sep = "")));
temp$dayNum <- dayNum;
dfFinal <- rbind(dfFinal, temp)
}
return(aggDataDay[,c('day', 'transactions')])
}
genTrans()
missingArgHandler <- function(argMissed,argDefault)
{
out <- ifelse(missing(argMissed),argDefault,argMissed);
return(out)
}
t <- genTrans()
t <- genTrans(spike = 12)
head(t)
genTrans <- function(cycles, trend, transactions, spike, outliers)
{
#handle missing arguments
cycles <- missingArgHandler(cycles,"y");
trend <- missingArgHandler(trend,1);
transactions <- missingArgHandler(transactions,10000);
outliers <- missingArgHandler(outliers, 1);
#Exception handling.
if(transactions <= 0)
{
stop("Please enter non zero positive integers");
}else if(transactions < 10000)
{
warning("Insights may not be meaningful. Recommended number of transactions for meaningful insights is 10,000.")
}
if(spike > 12 | spike < 1)
{
stop("Please set spike between 1 and 12")
}
if(trend == 1 | trend == -1)
{
}else
{
stop("Please set trend as 1 or -1");
}
if(outliers == 1 | outliers == 0)
{
}else
{
stop("Please set outliers as 1 or 0");
}
#compute weights for 12 months
if(missing(spike))
{
aggDataMth <- as.data.frame(buildDistr(cycles = cycles, trend = trend));
}else
{
distr <- buildDistr(cycles = cycles, trend = trend);
distrspiked <- buildSpike(distr = distr, spike = spike);
aggDataMth <- as.data.frame(distrspiked);
}
colnames(aggDataMth) <- c('distrWt');
wts <- (transactions/sum(aggDataMth$distrWt));
aggDataMth$weights <- (aggDataMth$distrWt*wts);
aggDataMth$mth <- row.names(aggDataMth);
daysInMth <- data.frame(matrix(nrow = 12, ncol = 1))
aggDataMth$days <- c(31 ,28 ,31 ,30 ,31 ,30 ,31 ,31 ,30 ,31 ,30 ,31);
#compute weights for 4 weeks each month
for(i in 1:nrow(aggDataMth))
{
aggDataDayTemp <- as.data.frame(buildDistr(st = 1, en = (aggDataMth$days[i]), cycles = "y", trend = trend));
colnames(aggDataDayTemp) <- c('distrWtWk')
wts <- (aggDataMth$weights[i]/sum(aggDataDayTemp$distrWtWk));
aggDataDayTemp$weights <- (aggDataDayTemp$distrWtWk*wts);
aggDataDayTemp$mth <- aggDataMth$mth[i];
if(i == 1)
{
aggDataDay <- aggDataDayTemp;
}else
{
aggDataDay <- rbind(aggDataDay, aggDataDayTemp);
}
}
aggDataDay$transactions <- round(aggDataDay$weights);
aggDataDay$day <- 1:nrow(aggDataDay);
#add outliers
if(outliers == 1)
{
aggDataDay$transactions <- (buildOutliers(aggDataDay$transactions));
}else if(outliers == 0)
{
aggDataDay <- aggDataDay;
}
aggDataDay$transactions <- round(aggDataDay$transactions, 0);
#build dataframe at transaction level
dfFinal <- data.frame()#build empty df
for(i in 1:nrow(aggDataDay))
{
numOfTrans <- aggDataDay$transactions[i];
dayNum <- aggDataDay$day[i];
temp <- as.data.frame(buildName(numOfItems = numOfTrans, prefix = paste("txn","-",i,"-",sep = "")));
temp$dayNum <- dayNum;
dfFinal <- rbind(dfFinal, temp)
}
return(dfFinal)
#return(aggDataDay[,c('day', 'transactions')])
}
t <- genTrans(spike = 12)
head(t)
View(head(t))
View(tail(t))
t[1:10]
t[1:10,]
genTrans <- function(cycles, trend, transactions, spike, outliers)
{
#handle missing arguments
cycles <- missingArgHandler(cycles,"y");
trend <- missingArgHandler(trend,1);
transactions <- missingArgHandler(transactions,10000);
outliers <- missingArgHandler(outliers, 1);
#Exception handling.
if(transactions <= 0)
{
stop("Please enter non zero positive integers");
}else if(transactions < 10000)
{
warning("Insights may not be meaningful. Recommended number of transactions for meaningful insights is 10,000.")
}
if(spike > 12 | spike < 1)
{
stop("Please set spike between 1 and 12")
}
if(trend == 1 | trend == -1)
{
}else
{
stop("Please set trend as 1 or -1");
}
if(outliers == 1 | outliers == 0)
{
}else
{
stop("Please set outliers as 1 or 0");
}
#compute weights for 12 months
if(missing(spike))
{
aggDataMth <- as.data.frame(buildDistr(cycles = cycles, trend = trend));
}else
{
distr <- buildDistr(cycles = cycles, trend = trend);
distrspiked <- buildSpike(distr = distr, spike = spike);
aggDataMth <- as.data.frame(distrspiked);
}
colnames(aggDataMth) <- c('distrWt');
wts <- (transactions/sum(aggDataMth$distrWt));
aggDataMth$weights <- (aggDataMth$distrWt*wts);
aggDataMth$mth <- row.names(aggDataMth);
daysInMth <- data.frame(matrix(nrow = 12, ncol = 1))
aggDataMth$days <- c(31 ,28 ,31 ,30 ,31 ,30 ,31 ,31 ,30 ,31 ,30 ,31);
#compute weights for 4 weeks each month
for(i in 1:nrow(aggDataMth))
{
aggDataDayTemp <- as.data.frame(buildDistr(st = 1, en = (aggDataMth$days[i]), cycles = "y", trend = trend));
colnames(aggDataDayTemp) <- c('distrWtWk')
wts <- (aggDataMth$weights[i]/sum(aggDataDayTemp$distrWtWk));
aggDataDayTemp$weights <- (aggDataDayTemp$distrWtWk*wts);
aggDataDayTemp$mth <- aggDataMth$mth[i];
if(i == 1)
{
aggDataDay <- aggDataDayTemp;
}else
{
aggDataDay <- rbind(aggDataDay, aggDataDayTemp);
}
}
aggDataDay$transactions <- round(aggDataDay$weights);
aggDataDay$day <- 1:nrow(aggDataDay);
#add outliers
if(outliers == 1)
{
aggDataDay$transactions <- (buildOutliers(aggDataDay$transactions));
}else if(outliers == 0)
{
aggDataDay <- aggDataDay;
}
aggDataDay$transactions <- round(aggDataDay$transactions, 0);
#build dataframe at transaction level
dfFinal <- data.frame()#build empty df
for(i in 1:nrow(aggDataDay))
{
numOfTrans <- aggDataDay$transactions[i];
dayNum <- aggDataDay$day[i];
mthNum <- aggDataDay$mth[i];
temp <- as.data.frame(buildName(numOfItems = numOfTrans, prefix = paste("txn","-",i,"-",sep = "")));
temp$dayNum <- dayNum;
temp$mthNum <- mthNum;
dfFinal <- rbind(dfFinal, temp)
}
return(dfFinal)
#return(aggDataDay[,c('day', 'transactions')])
}
t <- genTrans(spike = 12)
View(head(t))
View((t[1:100,]))
View((t[1:150,]))
View((t[1:200,]))
names(t)
View(head(t))
genTrans <- function(cycles, trend, transactions, spike, outliers)
{
#handle missing arguments
cycles <- missingArgHandler(cycles,"y");
trend <- missingArgHandler(trend,1);
transactions <- missingArgHandler(transactions,10000);
outliers <- missingArgHandler(outliers, 1);
#Exception handling.
if(transactions <= 0)
{
stop("Please enter non zero positive integers");
}else if(transactions < 10000)
{
warning("Insights may not be meaningful. Recommended number of transactions for meaningful insights is 10,000.")
}
if(spike > 12 | spike < 1)
{
stop("Please set spike between 1 and 12")
}
if(trend == 1 | trend == -1)
{
}else
{
stop("Please set trend as 1 or -1");
}
if(outliers == 1 | outliers == 0)
{
}else
{
stop("Please set outliers as 1 or 0");
}
#compute weights for 12 months
if(missing(spike))
{
aggDataMth <- as.data.frame(buildDistr(cycles = cycles, trend = trend));
}else
{
distr <- buildDistr(cycles = cycles, trend = trend);
distrspiked <- buildSpike(distr = distr, spike = spike);
aggDataMth <- as.data.frame(distrspiked);
}
colnames(aggDataMth) <- c('distrWt');
wts <- (transactions/sum(aggDataMth$distrWt));
aggDataMth$weights <- (aggDataMth$distrWt*wts);
aggDataMth$mth <- row.names(aggDataMth);
daysInMth <- data.frame(matrix(nrow = 12, ncol = 1))
aggDataMth$days <- c(31 ,28 ,31 ,30 ,31 ,30 ,31 ,31 ,30 ,31 ,30 ,31);
#compute weights for 4 weeks each month
for(i in 1:nrow(aggDataMth))
{
aggDataDayTemp <- as.data.frame(buildDistr(st = 1, en = (aggDataMth$days[i]), cycles = "y", trend = trend));
colnames(aggDataDayTemp) <- c('distrWtWk')
wts <- (aggDataMth$weights[i]/sum(aggDataDayTemp$distrWtWk));
aggDataDayTemp$weights <- (aggDataDayTemp$distrWtWk*wts);
aggDataDayTemp$mth <- aggDataMth$mth[i];
if(i == 1)
{
aggDataDay <- aggDataDayTemp;
}else
{
aggDataDay <- rbind(aggDataDay, aggDataDayTemp);
}
}
aggDataDay$transactions <- round(aggDataDay$weights);
aggDataDay$day <- 1:nrow(aggDataDay);
#add outliers
if(outliers == 1)
{
aggDataDay$transactions <- (buildOutliers(aggDataDay$transactions));
}else if(outliers == 0)
{
aggDataDay <- aggDataDay;
}
aggDataDay$transactions <- round(aggDataDay$transactions, 0);
#build dataframe at transaction level
dfFinal <- data.frame()#build empty df
for(i in 1:nrow(aggDataDay))
{
numOfTrans <- aggDataDay$transactions[i];
dayNum <- aggDataDay$day[i];
mthNum <- aggDataDay$mth[i];
temp <- as.data.frame(buildName(numOfItems = numOfTrans, prefix = paste("txn","-",i,"-",sep = "")));
names(temp) <- c("transactionID")
temp$dayNum <- dayNum;
temp$mthNum <- mthNum;
dfFinal <- rbind(dfFinal, temp)
}
return(dfFinal)
#return(aggDataDay[,c('day', 'transactions')])
}
t <- genTrans()
t <- genTrans(spike = 12)
head(t)
library(conjurer)
transactions <- genTrans(cycles = "y", spike = 12, outliers = 1, transactions = 10000)
View(head(transactions))
test <- c(80,20)
test
class(test)
