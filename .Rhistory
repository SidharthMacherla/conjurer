#compute prob(next). Note that row or column sum does not matter as its the same.
nextAlpha <- names(sumRowProb[i])
#compute prob(next|current) testing with just next alpha
probNextAlphaGivenCur <- sumRowProb[nextAlpha]
listOfProbs <- c(listOfProbs,list(probNextAlphaGivenCur))
}
#pick the next alphabet randomly from the top few highest probabilities
unlistOfProbs <- unlist(listOfProbs)
sortedProb <- sort(unlistOfProbs, decreasing = TRUE)
nextAlphaFinal <- names(sortedProb[randNum])
return(nextAlphaFinal)
}
nextAlphaProb(alphaMatrix = alphaMatrixFirst, currentAlpha = firstAlpha, placement = "first")
matrixSubsetCur
class(matrixSubsetCur)
length(matrixSubsetCur)
sumRowProb
class(sumRowProb)
maxRange <- min(length(sumRowProb), 3)
maxRange
nextAlphaProb <- function(alphaMatrix, currentAlpha, placement)
{
matrixSubsetCur <- alphaMatrix[currentAlpha,]
sumRowProb <- prop.table(matrixSubsetCur)
#select the range of sumRowProb This is particularly important if the length of sumRowProb is less than 3
maxRange <- min(length(sumRowProb), 3)
#add randomness
randNum <- sample(1:maxRange,1)
#compute prob(current)
listOfProbs <- list()
for(i in seq_along(sumRowProb))
{
#compute prob(next). Note that row or column sum does not matter as its the same.
nextAlpha <- names(sumRowProb[i])
#compute prob(next|current) testing with just next alpha
probNextAlphaGivenCur <- sumRowProb[nextAlpha]
listOfProbs <- c(listOfProbs,list(probNextAlphaGivenCur))
}
#pick the next alphabet randomly from the top few highest probabilities
unlistOfProbs <- unlist(listOfProbs)
sortedProb <- sort(unlistOfProbs, decreasing = TRUE)
nextAlphaFinal <- names(sortedProb[randNum])
return(nextAlphaFinal)
}
nextAlphaProb(alphaMatrix = alphaMatrixFirst, currentAlpha = firstAlpha, placement = "first")
nextAlphaProb(alphaMatrix = alphaMatrixFirst, currentAlpha = firstAlpha, placement = "first")
nextAlphaProb(alphaMatrix = alphaMatrixFirst, currentAlpha = firstAlpha, placement = "all")
library(conjurer)
df_names = data.frame(names = c("Oliver", "Jack", "Harry"),
stringsAsFactors = FALSE)
df_names
buildNames(df_names, numOfNames = 3, minLength = 5, maxLength = 7)
buildNames <- function(dframe, numOfNames, minLength, maxLength)
{
#if training data is provided, build the matrix. Otherwise, use the default matrix
if(!missing(dframe))
{
#generate alphamatrix
alphaMatrixFirst <- genMatrix(dframe,"first")
alphaMatrixAll <- genMatrix(dframe,"all")
#alphaMatrixLast <- genMatrix(dframe,"last")
}
#build top frequency alphas
topAlphas <- rowSums(alphaMatrixFirst)
topAlphas <- topAlphas[order(-topAlphas)]
#select the range of topAlphas. This is particularly important if the length of topAlphas is less than 13
maxRange <- min(length(topAlphas), 13)
#select the high frequency beginning alphabets
n <- sample(topAlphas[1:maxRange],numOfNames, replace = TRUE)
custNames <- list()
for(i in seq_along(n))
{
firstAlpha <- names(n[i])
secondAlpha <- nextAlphaProb(alphaMatrix = alphaMatrixFirst, currentAlpha = firstAlpha, placement = "first")
custName <- list(firstAlpha,secondAlpha)
prevAlpha <- paste0(unlist(custName),collapse = "")
nameLength <- sample(minLength:maxLength, 1, replace = FALSE)
for(j in 3:nameLength)
{
nextAlpha <- nextAlphaProb(alphaMatrix = alphaMatrixAll, currentAlpha = prevAlpha, placement = "all")
custName <- list(custName,nextAlpha)
custName <- unlist(custName)
prevAlpha <- paste0(custName[length(custName)-1], custName[length(custName)], collapse = "")
}#ends inner for
custName <- paste0(custName, collapse = "")
custNames <- c(unlist(custNames), custName)
}#ends for
return(custNames)
}
#' @title Generate Frequency Distribution Matrix
#' @description For a given names dataframe and placement, a frequency distribution table is returned.
#' @param dframe A dataframe with one column that has one name per row. These names must be english alphabets from A to Z and must not include any non-alphabet characters such as as hyphen or apostrophe.
#' @param placement A string argument that takes three values namely "first", "last" and "all". Currently, only "first" and "all" are used while the option "last" is a placeholder for future versions of the package **conjurer**
#' @return A table. The rows and columns of the table depend on the argument \emph{placement}. A detailed explanation is as given below in the detail section.
#' @details The purpose of this function is to generate a frequency distribution table of alphabets. There are currently 2 tables that could be generated using this function.
#' The first table is generated using the internal function \code{\link{genFirstPairs}}. For this, the argument \emph{placement} is assigned the value "first". The rows of the table returned by the function represent the first alphabet of the string and the columns represent the second alphabet. The values in the table represent the number of times the combination is observed i.e the combination of the row and column alphabets.
#' The second table is generated using the internal function \code{\link{genTriples}}. For this, the argument \emph{placement} is assigned the value "all". The rows of the table returned by the function represent two consecutive alphabets of the string and the columns represent the third consecutive alphabet. The values in the table represent the number of times the combination is observed i.e the combination of the row and column alphabets.
genMatrix <- function(dframe, placement)
{
if(placement == "first")
{
alphaList <- apply(X = dframe, MARGIN = 1, FUN = function(x) genFirstPairs(x))
rowStart <- 1
rowEnd <- 1
colStart <- 2
colEnd <- 2
}else if(placement == "all")
{
alphaList <- apply(X = dframe, MARGIN = 1, FUN = function(x) genTriples(x))
rowStart <- 1
rowEnd <- 2
colStart <- 3
colEnd <- 3
}
alphaUnList <- unlist(alphaList, use.names = FALSE)
alphaUnList <- tolower(alphaUnList)
alphaUnListDf <- data.frame(alphaUnList)
names(alphaUnListDf) <- c("alphabets")
alphaUnListDf$rowAlpha <- substr(alphaUnListDf$alphabets,rowStart,rowEnd)
alphaUnListDf$colAlpha <- substr(alphaUnListDf$alphabets,colStart,colEnd)
alphaUnListDf$alphabets <- NULL
alphaUnListDfTable <- table(alphaUnListDf$rowAlpha, alphaUnListDf$colAlpha)
return(alphaUnListDfTable)
}
#' @title Extracts Three Consecutive Alphabets of the String
#' @description For a given string, this function extracts three consecutive alphabets. This function is further used by \code{\link{genMatrix}} function.
#' @param s A string. This is the string from which three consecutive alphabets are to be extracted.
#' @return List of three alphabet combinations of the string input.
genTriples <- function(s)
{
s2 <- unlist(strsplit(s,""))
triples <- list()
for(i in seq_along(s2))
{
if(i < (length(s2)-1))
{
triple <- paste(s2[i],s2[i+1], s2[i+2], sep = "")
triples <- c(triples,triple)
}#ends if
}#ends for
return(triples)
}
#' @title Generate Next Alphabet
#' @description Generates next alphabet based on prior probabilities.
#' @param alphaMatrix A table. This table is generated using the \code{\link{genMatrix}} function .
#' @param currentAlpha A string. This is the alphabet(s) for which the next alphabet is generated.
#' @param placement A string. This takes one of the two values namely "first" or "all".
#' @return The next alphabet following the input alphabet(s) passed by the argument \emph{currentAlpha}.
#' @details The purpose of this function is to generate the next alphabet for a given alphabet(s). This function uses prior probabilities to generate the next alphabet. Although there are two types of input tables passed into the function by using the parameter \emph{alphaMatrix}, the process to generate the next alphabet remains the same as given below.
#'
#' Firstly, the input table contains frequencies of the combination of current alphabet \emph{currentAlpha} (represented by rows) and next alphabet(represented by columns). These frequencies are converted into a percentage at a row level. This means that for each row, the sum of all the column values will add to 1.
#'
#' Secondly, for the given \emph{currentAlpha}, the table is looked up for the corresponding column where the probability is the highest. The alphabet for the column with maximum prior probability is selected as the next alphabet and is returned by the function.
nextAlphaProb <- function(alphaMatrix, currentAlpha, placement)
{
matrixSubsetCur <- alphaMatrix[currentAlpha,]
sumRowProb <- prop.table(matrixSubsetCur)
#select the range of sumRowProb This is particularly important if the length of sumRowProb is less than 3
maxRange <- min(length(sumRowProb), 3)
#add randomness
randNum <- sample(1:maxRange,1)
#compute prob(current)
listOfProbs <- list()
for(i in seq_along(sumRowProb))
{
#compute prob(next). Note that row or column sum does not matter as its the same.
nextAlpha <- names(sumRowProb[i])
#compute prob(next|current) testing with just next alpha
probNextAlphaGivenCur <- sumRowProb[nextAlpha]
listOfProbs <- c(listOfProbs,list(probNextAlphaGivenCur))
}
#pick the next alphabet randomly from the top few highest probabilities
unlistOfProbs <- unlist(listOfProbs)
sortedProb <- sort(unlistOfProbs, decreasing = TRUE)
nextAlphaFinal <- names(sortedProb[randNum])
return(nextAlphaFinal)
}
#' @title Extracts the First Two Alphabets of the String
#' @description For a given string, this function extracts the first two alphabets. This function is further used by \code{\link{genMatrix}} function.
#' @param s A string. This is the string from which the first two alphabets are to be extracted.
#' @return First two alphabets of the string input.
genFirstPairs <- function(s)
{
s2 <- unlist(strsplit(s,""))
pair <- paste(s2[1],s2[2], sep = "")
return(pair)
}
buildNames(df_names, numOfNames = 3, minLength = 5, maxLength = 7)
dframe <- df_names
alphaMatrixFirst <- genMatrix(dframe,"first")
alphaMatrixAll <- genMatrix(dframe,"all")
alphaMatrixFirst
alphaMatrixAll
topAlphas <- rowSums(alphaMatrixFirst)
topAlphas
topAlphas <- topAlphas[order(-topAlphas)]
topAlphas
maxRange <- min(length(topAlphas), 13)
maxRange
n <- sample(topAlphas[1:maxRange],numOfNames, replace = TRUE)
custNames <- list()
for(i in seq_along(n))
{
firstAlpha <- names(n[i])
secondAlpha <- nextAlphaProb(alphaMatrix = alphaMatrixFirst, currentAlpha = firstAlpha, placement = "first")
custName <- list(firstAlpha,secondAlpha)
prevAlpha <- paste0(unlist(custName),collapse = "")
nameLength <- sample(minLength:maxLength, 1, replace = FALSE)
for(j in 3:nameLength)
{
nextAlpha <- nextAlphaProb(alphaMatrix = alphaMatrixAll, currentAlpha = prevAlpha, placement = "all")
custName <- list(custName,nextAlpha)
custName <- unlist(custName)
prevAlpha <- paste0(custName[length(custName)-1], custName[length(custName)], collapse = "")
}#ends inner for
custName <- paste0(custName, collapse = "")
custNames <- c(unlist(custNames), custName)
}#ends for
minLength <- 5
maxLength <- 7
for(i in seq_along(n))
{
firstAlpha <- names(n[i])
secondAlpha <- nextAlphaProb(alphaMatrix = alphaMatrixFirst, currentAlpha = firstAlpha, placement = "first")
custName <- list(firstAlpha,secondAlpha)
prevAlpha <- paste0(unlist(custName),collapse = "")
nameLength <- sample(minLength:maxLength, 1, replace = FALSE)
for(j in 3:nameLength)
{
nextAlpha <- nextAlphaProb(alphaMatrix = alphaMatrixAll, currentAlpha = prevAlpha, placement = "all")
custName <- list(custName,nextAlpha)
custName <- unlist(custName)
prevAlpha <- paste0(custName[length(custName)-1], custName[length(custName)], collapse = "")
}#ends inner for
custName <- paste0(custName, collapse = "")
custNames <- c(unlist(custNames), custName)
}#ends for
for(i in seq_along(n))
{
firstAlpha <- names(n[i])
print(i)
secondAlpha <- nextAlphaProb(alphaMatrix = alphaMatrixFirst, currentAlpha = firstAlpha, placement = "first")
custName <- list(firstAlpha,secondAlpha)
prevAlpha <- paste0(unlist(custName),collapse = "")
nameLength <- sample(minLength:maxLength, 1, replace = FALSE)
for(j in 3:nameLength)
{
nextAlpha <- nextAlphaProb(alphaMatrix = alphaMatrixAll, currentAlpha = prevAlpha, placement = "all")
custName <- list(custName,nextAlpha)
custName <- unlist(custName)
prevAlpha <- paste0(custName[length(custName)-1], custName[length(custName)], collapse = "")
}#ends inner for
custName <- paste0(custName, collapse = "")
custNames <- c(unlist(custNames), custName)
}#ends for
i = 1
firstAlpha <- names(n[i])
firstAlpha
print(i)
secondAlpha <- nextAlphaProb(alphaMatrix = alphaMatrixFirst, currentAlpha = firstAlpha, placement = "first")
secondAlpha
custName <- list(firstAlpha,secondAlpha)
custName
prevAlpha <- paste0(unlist(custName),collapse = "")
prevAlpha
alphaMatrixFirst
nextAlphaProb(alphaMatrix = alphaMatrixFirst, currentAlpha = firstAlpha, placement = "first")
firstAlpha
secondAlpha <- nextAlphaProb(alphaMatrix = alphaMatrixFirst, currentAlpha = firstAlpha, placement = "first")
secondAlpha
firstAlpha
custName <- list(firstAlpha,secondAlpha)
custName
prevAlpha <- paste0(unlist(custName),collapse = "")
prevAlpha
nameLength <- sample(minLength:maxLength, 1, replace = FALSE)
nameLength
3:nameLength
j = 3
nextAlphaProb(alphaMatrix = alphaMatrixAll, currentAlpha = prevAlpha, placement = "all")
nextAlpha <- nextAlphaProb(alphaMatrix = alphaMatrixAll, currentAlpha = prevAlpha, placement = "all")
custName <- list(custName,nextAlpha)
custName
custName <- unlist(custName)
custName
prevAlpha <- paste0(custName[length(custName)-1], custName[length(custName)], collapse = "")
prevAlpha
custName <- paste0(custName, collapse = "")
custName
custNames <- c(unlist(custNames), custName)
custNames
for(i in seq_along(n))
{
firstAlpha <- names(n[i])
print(i)
secondAlpha <- nextAlphaProb(alphaMatrix = alphaMatrixFirst, currentAlpha = firstAlpha, placement = "first")
custName <- list(firstAlpha,secondAlpha)
prevAlpha <- paste0(unlist(custName),collapse = "")
nameLength <- sample(minLength:maxLength, 1, replace = FALSE)
for(j in 3:nameLength)
{
nextAlpha <- nextAlphaProb(alphaMatrix = alphaMatrixAll, currentAlpha = prevAlpha, placement = "all")
custName <- list(custName,nextAlpha)
custName <- unlist(custName)
prevAlpha <- paste0(custName[length(custName)-1], custName[length(custName)], collapse = "")
}#ends inner for
custName <- paste0(custName, collapse = "")
custNames <- c(unlist(custNames), custName)
}#ends for
for(i in seq_along(n))
{
firstAlpha <- names(n[i])
secondAlpha <- nextAlphaProb(alphaMatrix = alphaMatrixFirst, currentAlpha = firstAlpha, placement = "first")
custName <- list(firstAlpha,secondAlpha)
prevAlpha <- paste0(unlist(custName),collapse = "")
nameLength <- sample(minLength:maxLength, 1, replace = FALSE)
for(j in 3:nameLength)
{
print(j)
nextAlpha <- nextAlphaProb(alphaMatrix = alphaMatrixAll, currentAlpha = prevAlpha, placement = "all")
custName <- list(custName,nextAlpha)
custName <- unlist(custName)
prevAlpha <- paste0(custName[length(custName)-1], custName[length(custName)], collapse = "")
}#ends inner for
custName <- paste0(custName, collapse = "")
custNames <- c(unlist(custNames), custName)
}#ends for
nextAlphaProb(alphaMatrix = alphaMatrixAll, currentAlpha = prevAlpha, placement = "all")
i = 1
firstAlpha <- names(n[i])
secondAlpha <- nextAlphaProb(alphaMatrix = alphaMatrixFirst, currentAlpha = firstAlpha, placement = "first")
custName <- list(firstAlpha,secondAlpha)
prevAlpha <- paste0(unlist(custName),collapse = "")
nameLength <- sample(minLength:maxLength, 1, replace = FALSE)
nameLength <- sample(minLength:maxLength, 1, replace = FALSE)
nameLength
3:nameLength
j = 6
nextAlpha <- nextAlphaProb(alphaMatrix = alphaMatrixAll, currentAlpha = prevAlpha, placement = "all")
alphaMatrixAll
currentAlpha
placement
nextAlphaProb(alphaMatrix = alphaMatrixAll, currentAlpha = prevAlpha, placement = "all")
alphaMatrix = alphaMatrixAll
currentAlpha = prevAlpha
placement = "all"
alphaMatrix[currentAlpha,]
currentAlpha
alphaMatrix
alphaMatrixFirst
?tryCatch()
tryCatch(1, finally = print("Hello"))
?try
try(log("a"))
tryCatch(log("a"))
tryCatch(log("a"), finally = print("testing"))
tryCatch({log(a)})
?tryCatch
currentAlpha
nextAlphaProb <- function(alphaMatrix, currentAlpha, placement)
{
#matrixSubsetCur <- alphaMatrix[currentAlpha,]
matrixSubsetCur <- tryCatch(
expr = alphaMatrix[currentAlpha,],
error = function(e){("doesNotExist")}
break
)
sumRowProb <- prop.table(matrixSubsetCur)
#select the range of sumRowProb This is particularly important if the length of sumRowProb is less than 3
maxRange <- min(length(sumRowProb), 3)
#add randomness
randNum <- sample(1:maxRange,1)
#compute prob(current)
listOfProbs <- list()
for(i in seq_along(sumRowProb))
{
#compute prob(next). Note that row or column sum does not matter as its the same.
nextAlpha <- names(sumRowProb[i])
#compute prob(next|current) testing with just next alpha
probNextAlphaGivenCur <- sumRowProb[nextAlpha]
listOfProbs <- c(listOfProbs,list(probNextAlphaGivenCur))
}
#pick the next alphabet randomly from the top few highest probabilities
unlistOfProbs <- unlist(listOfProbs)
sortedProb <- sort(unlistOfProbs, decreasing = TRUE)
nextAlphaFinal <- names(sortedProb[randNum])
return(nextAlphaFinal)
}
nextAlphaProb <- function(alphaMatrix, currentAlpha, placement)
{
#matrixSubsetCur <- alphaMatrix[currentAlpha,]
matrixSubsetCur <- tryCatch(
expr = alphaMatrix[currentAlpha,],
error = function(e){("doesNotExist") break}
)
sumRowProb <- prop.table(matrixSubsetCur)
#select the range of sumRowProb This is particularly important if the length of sumRowProb is less than 3
maxRange <- min(length(sumRowProb), 3)
#add randomness
randNum <- sample(1:maxRange,1)
#compute prob(current)
listOfProbs <- list()
for(i in seq_along(sumRowProb))
{
#compute prob(next). Note that row or column sum does not matter as its the same.
nextAlpha <- names(sumRowProb[i])
#compute prob(next|current) testing with just next alpha
probNextAlphaGivenCur <- sumRowProb[nextAlpha]
listOfProbs <- c(listOfProbs,list(probNextAlphaGivenCur))
}
#pick the next alphabet randomly from the top few highest probabilities
unlistOfProbs <- unlist(listOfProbs)
sortedProb <- sort(unlistOfProbs, decreasing = TRUE)
nextAlphaFinal <- names(sortedProb[randNum])
return(nextAlphaFinal)
}
test <- try(t <- log(10))
class(test)
test <- try(t <- log(a))
class(test)
test <- try(t <- log(a), silent = TRUE)
class(test)
if(class(test) == "try-error"){print("yes")}
test <- try(t <- log(10), silent = TRUE)
if(class(test) == "try-error"){print("yes")}
nextAlphaProb <- function(alphaMatrix, currentAlpha, placement)
{
#matrixSubsetCur <- alphaMatrix[currentAlpha,]
tryCatchTest <- try(matrixSubsetCur <- alphaMatrix[currentAlpha,])
if(class(tryCatchTest) == "try-error")
{
nextAlphaFinal <- "doesNotExist"
return(nextAlphaFinal)
}
sumRowProb <- prop.table(matrixSubsetCur)
#select the range of sumRowProb This is particularly important if the length of sumRowProb is less than 3
maxRange <- min(length(sumRowProb), 3)
#add randomness
randNum <- sample(1:maxRange,1)
#compute prob(current)
listOfProbs <- list()
for(i in seq_along(sumRowProb))
{
#compute prob(next). Note that row or column sum does not matter as its the same.
nextAlpha <- names(sumRowProb[i])
#compute prob(next|current) testing with just next alpha
probNextAlphaGivenCur <- sumRowProb[nextAlpha]
listOfProbs <- c(listOfProbs,list(probNextAlphaGivenCur))
}
#pick the next alphabet randomly from the top few highest probabilities
unlistOfProbs <- unlist(listOfProbs)
sortedProb <- sort(unlistOfProbs, decreasing = TRUE)
nextAlphaFinal <- names(sortedProb[randNum])
return(nextAlphaFinal)
}
alphaMatrix = alphaMatrixAll
library(conjurer)
df_names = data.frame(names = c("Oliver", "Jack", "Harry"),
stringsAsFactors = FALSE)
df_names
buildNames(df_names, numOfNames = 3, minLength = 5, maxLength = 7)
library(conjurer)
buildNames(df_names, numOfNames = 3, minLength = 5, maxLength = 7)
library(conjurer)
buildNames(df_names, numOfNames = 3, minLength = 5, maxLength = 7)
prevAlpha
prevAlpha <- "ab"
prevAlpha[1]
prevAlpha[1,]
class(prevAlpha)
prevAlpha[[1]]
?strsplit
strsplit(prevAlpha)
strsplit(prevAlpha, split = "")
unlist(strsplit(prevAlpha, split = ""))
unlist(strsplit(prevAlpha, split = ""))[2]
library(conjurer)
buildNames(df_names, numOfNames = 3, minLength = 5, maxLength = 7)
library(conjurer)
df_names = data.frame(names = c("Oliver", "Jack", "Harry"),
stringsAsFactors = FALSE)
new_names = buildNames(df_names, numOfNames = 3, minLength = 5, maxLength = 7)
new_names
library(conjurer)
new_names = buildNames(df_names, numOfNames = 3, minLength = 5, maxLength = 7)
new_names
library(conjurer)
buildNames(df_names, numOfNames = 3, minLength = 5, maxLength = 7)
names <- buildNames(df_names, numOfNames = 3, minLength = 5, maxLength = 7)
names
library(conjurer)
library(babynames)
test <- babynames::babynames
nrow(test)
head(test)
head(test$name)
df_names <- head(test$name)
df_names
class(df_names)
df_names <- as.data.frame(head(test$name))
df_names
class(df_names)
buildNames(df_names, 3,5,7)
buildNames( numOfNames = 3, minLength = 5, maxLength = 7)
buildNames(df_names, 3,5,7)
df_names <- as.data.frame((test$name[1:100]))
df_names
buildNames(df_names, 3,5,7)
df_names <- as.data.frame((test$name[1:1000]))
buildNames(df_names, 3,5,7)
df_names <- as.data.frame((test$name[1:10000]))
buildNames(df_names, 3,5,7)
